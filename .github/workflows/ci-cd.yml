name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - master
      - develop
  pull_request:
    branches:
      - main
      - master
      - develop

env:
  PYTHON_VERSION: "3.12"
  DOCKER_IMAGE_NAME: aimino-api
  DOCKER_REGISTRY: ghcr.io

jobs:
  # Step 1: Build Docker Image (first step, all other jobs depend on this)
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    # Grant permissions to push packages
    permissions:
      contents: read
      packages: write
    # Allow build to succeed even if push fails (for permission issues)
    continue-on-error: false
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      build-success: ${{ steps.build.outcome == 'success' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build Docker image (always build, push is optional)
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./src/api_service/Dockerfile
          # Always build, but don't push (push will be done separately)
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Load image locally for system tests
          load: true

      - name: Push Docker image (optional, may fail due to permissions)
        if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
        run: |
          # Try to push, but don't fail the job if it fails due to permissions
          tags="${{ steps.meta.outputs.tags }}"
          for tag in $tags; do
            docker push "$tag" || echo "⚠️ Failed to push $tag (likely permission issue), continuing..."
          done
        continue-on-error: true

  # Step 2: Parallel jobs - Tests and Lint/Format
  # Unit Tests
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: build
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles('**/requirements*.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ matrix.python-version }}-

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libgl1 libglib2.0-0

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov pytest-mock pytest-asyncio requests
          pip install -e "src/api_service[test]"
          pip install -e "aimino_frontend"

      - name: Run unit tests
        run: |
          pytest -m unit --cov=src/api_service --cov=aimino_frontend \
            --cov-report=term-missing --cov-report=xml \
            --junit-xml=junit-unit-${{ matrix.python-version }}.xml \
            --cov-fail-under=0 \
            --cov-data-file=.coverage.unit.${{ matrix.python-version }} \
            -v

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        with:
          name: coverage-data-unit
          path: |
            .coverage.unit.${{ matrix.python-version }}
            coverage.xml
          retention-days: 1

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-unit-${{ matrix.python-version }}
          path: junit-unit-${{ matrix.python-version }}.xml

  # Merge Unit Tests Coverage
  merge-unit-coverage:
    name: Merge Unit Tests Coverage
    runs-on: ubuntu-latest
    needs: unit-tests
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install coverage tools
        run: |
          python -m pip install --upgrade pip
          pip install coverage pytest-cov

      - name: Download all unit coverage data
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-data-unit
          merge-multiple: true

      - name: Merge unit coverage reports
        run: |
          # List downloaded files for debugging
          ls -la .coverage.unit.* 2>/dev/null || echo "No .coverage.unit.* files found"
          # Combine all .coverage files
          if ls .coverage.unit.* 1> /dev/null 2>&1; then
            coverage combine .coverage.unit.*
            # Generate merged reports
            coverage xml -o coverage-unit-merged.xml
            coverage html -d htmlcov-unit
            coverage report --show-missing > coverage-unit-summary.txt
            echo "Unit Tests Coverage Summary:"
            cat coverage-unit-summary.txt
          else
            echo "⚠️  No coverage data files found, skipping merge"
            # Create empty reports
            touch coverage-unit-merged.xml coverage-unit-summary.txt
            mkdir -p htmlcov-unit
          fi

      - name: Upload merged unit coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-unit
          path: |
            coverage-unit-merged.xml
            htmlcov-unit/
            coverage-unit-summary.txt
          retention-days: 7

  # Integration Tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: build
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles('**/requirements*.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ matrix.python-version }}-

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libgl1 libglib2.0-0

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov pytest-mock pytest-asyncio requests
          pip install -e "src/api_service[test]"
          pip install -e "aimino_frontend"

      - name: Run integration tests
        run: |
          pytest -m integration --cov=src/api_service --cov=aimino_frontend \
            --cov-report=term-missing --cov-report=xml \
            --junit-xml=junit-integration-${{ matrix.python-version }}.xml \
            --cov-fail-under=0 \
            --cov-data-file=.coverage.integration.${{ matrix.python-version }} \
            -v

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        with:
          name: coverage-data-integration
          path: |
            .coverage.integration.${{ matrix.python-version }}
            coverage.xml
          retention-days: 1

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-integration-${{ matrix.python-version }}
          path: junit-integration-${{ matrix.python-version }}.xml

  # Merge Integration Tests Coverage
  merge-integration-coverage:
    name: Merge Integration Tests Coverage
    runs-on: ubuntu-latest
    needs: integration-tests
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install coverage tools
        run: |
          python -m pip install --upgrade pip
          pip install coverage pytest-cov

      - name: Download all integration coverage data
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-data-integration
          merge-multiple: true

      - name: Merge integration coverage reports
        run: |
          # List downloaded files for debugging
          ls -la .coverage.integration.* 2>/dev/null || echo "No .coverage.integration.* files found"
          # Combine all .coverage files
          if ls .coverage.integration.* 1> /dev/null 2>&1; then
            coverage combine .coverage.integration.*
            # Generate merged reports
            coverage xml -o coverage-integration-merged.xml
            coverage html -d htmlcov-integration
            coverage report --show-missing > coverage-integration-summary.txt
            echo "Integration Tests Coverage Summary:"
            cat coverage-integration-summary.txt
          else
            echo "⚠️  No coverage data files found, skipping merge"
            # Create empty reports
            touch coverage-integration-merged.xml coverage-integration-summary.txt
            mkdir -p htmlcov-integration
          fi

      - name: Upload merged integration coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-integration
          path: |
            coverage-integration-merged.xml
            htmlcov-integration/
            coverage-integration-summary.txt
          retention-days: 7

  # System Tests (requires Docker image)
  system-tests:
    name: System Tests
    runs-on: ubuntu-latest
    needs: build
    # Run system tests even if build push failed (build still succeeded)
    if: github.event_name != 'pull_request' && needs.build.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for system tests
        run: |
          # Build the image locally for system tests (reuse cache from build job)
          docker build -t aimino-api-test:${{ github.sha }} -f src/api_service/Dockerfile .
          # Also tag as latest for convenience
          docker tag aimino-api-test:${{ github.sha }} aimino-api-test:latest

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install test dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov requests

      - name: Run API server in background
        run: |
          docker run -d -p 8000:8000 \
            -e AIMINO_SKIP_STARTUP=1 \
            -e GEMINI_API_KEY=dummy_key_for_testing \
            --name aimino-api-test \
            aimino-api-test:latest
          sleep 10

      - name: Run system tests
        run: |
          API_BASE_URL=http://localhost:8000 pytest -m system -v --junit-xml=junit-system.xml || true

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-system
          path: junit-system.xml

      - name: Cleanup
        if: always()
        run: |
          docker stop aimino-api-test || true
          docker rm aimino-api-test || true

  # Lint and Format Check (runs in parallel with tests)
  lint-and-format:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install linting tools
        run: |
          python -m pip install --upgrade pip
          pip install ruff black

      - name: Run Ruff linter
        run: |
          ruff check src/api_service/ aimino_frontend/ || true
        continue-on-error: true

      - name: Run Black formatter check
        run: |
          black --check --line-length 120 src/api_service/ aimino_frontend/ || true
        continue-on-error: true

  # Step 3: Test Summary (aggregates all test results)
  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, system-tests, lint-and-format, merge-unit-coverage, merge-integration-coverage]
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          merge-multiple: true

      - name: Download merged coverage reports
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-report-*
          merge-multiple: true

      - name: Check coverage threshold
        run: |
          python -m pip install --upgrade pip
          pip install coverage
          
          # Combine unit and integration coverage if both exist
          if [ -f coverage-unit-merged.xml ] && [ -f coverage-integration-merged.xml ]; then
            # Parse both XML files and calculate combined coverage
            python << 'EOF'
          import xml.etree.ElementTree as ET
          import sys
          
          try:
              # Parse unit tests coverage
              unit_tree = ET.parse('coverage-unit-merged.xml')
              unit_root = unit_tree.getroot()
              unit_rate = float(unit_root.get('line-rate', 0))
              
              # Parse integration tests coverage
              int_tree = ET.parse('coverage-integration-merged.xml')
              int_root = int_tree.getroot()
              int_rate = float(int_root.get('line-rate', 0))
              
              # Calculate combined coverage (simple average for now)
              # In practice, you might want to merge the actual coverage data
              combined_rate = (unit_rate + int_rate) / 2 * 100
              print(f"Unit Tests Coverage: {unit_rate * 100:.2f}%")
              print(f"Integration Tests Coverage: {int_rate * 100:.2f}%")
              print(f"Combined Coverage: {combined_rate:.2f}%")
              
              if combined_rate < 61:
                  print(f"❌ Combined coverage {combined_rate:.2f}% is below 61% threshold")
                  sys.exit(1)
              else:
                  print(f"✅ Combined coverage {combined_rate:.2f}% meets 61% threshold")
          except Exception as e:
              print(f"⚠️  Error checking coverage: {e}")
              import traceback
              traceback.print_exc()
              sys.exit(0)
          EOF
          elif [ -f coverage-unit-merged.xml ]; then
            python << 'EOF'
          import xml.etree.ElementTree as ET
          import sys
          tree = ET.parse('coverage-unit-merged.xml')
          root = tree.getroot()
          rate = float(root.get('line-rate', 0)) * 100
          print(f"Unit Tests Coverage: {rate:.2f}%")
          if rate < 61:
              print(f"❌ Coverage {rate:.2f}% is below 61% threshold")
              sys.exit(1)
          else:
              print(f"✅ Coverage {rate:.2f}% meets 61% threshold")
          EOF
          elif [ -f coverage-integration-merged.xml ]; then
            python << 'EOF'
          import xml.etree.ElementTree as ET
          import sys
          tree = ET.parse('coverage-integration-merged.xml')
          root = tree.getroot()
          rate = float(root.get('line-rate', 0)) * 100
          print(f"Integration Tests Coverage: {rate:.2f}%")
          if rate < 61:
              print(f"❌ Coverage {rate:.2f}% is below 61% threshold")
              sys.exit(1)
          else:
              print(f"✅ Coverage {rate:.2f}% meets 61% threshold")
          EOF
          else
            echo "⚠️  Coverage reports not found, skipping threshold check"
          fi
        continue-on-error: true

      - name: Generate test summary
        run: |
          echo "### CI/CD Pipeline Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test Type | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | ${{ needs.unit-tests.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ${{ needs.integration-tests.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| System Tests | ${{ needs.system-tests.result == 'success' && '✅ Passed' || needs.system-tests.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Lint and Format | ${{ needs.lint-and-format.result == 'success' && '✅ Passed' || '⚠️ Warnings' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Coverage reports are available in the artifacts above." >> $GITHUB_STEP_SUMMARY

      - name: Upload final coverage summary
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report-final
          path: |
            coverage-unit-merged.xml
            coverage-integration-merged.xml
            htmlcov-unit/
            htmlcov-integration/
            coverage-unit-summary.txt
            coverage-integration-summary.txt
        continue-on-error: true

      - name: Check overall test status
        run: |
          if [ "${{ needs.unit-tests.result }}" != "success" ] || \
             [ "${{ needs.integration-tests.result }}" != "success" ] || \
             ([ "${{ needs.system-tests.result }}" != "success" ] && [ "${{ needs.system-tests.result }}" != "skipped" ]); then
            echo "❌ Some tests failed!"
            exit 1
          else
            echo "✅ All tests passed!"
          fi

  # Step 4: Deploy to Kubernetes (only when merging to main)
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [test-summary]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && needs.test-summary.result == 'success'
    continue-on-error: true
    environment:
      name: production
      url: https://your-k8s-cluster-url.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Authenticate to GKE
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
        if: env.GCP_SA_KEY != ''

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        if: env.GCP_SA_KEY != ''

      - name: Configure kubectl for GKE
        run: |
          # For GKE clusters, use gcloud to get credentials
          if [ -n "${{ secrets.GCP_SA_KEY }}" ]; then
            gcloud container clusters get-credentials aimino-app-cluster \
              --zone us-central1 \
              --project alpine-avatar-473401
            echo "✓ GKE credentials configured successfully"
          else
            echo "⚠️  GCP_SA_KEY not configured, trying KUBECONFIG..."
            # Fallback to KUBECONFIG if GCP_SA_KEY is not available
            if [ -n "${{ secrets.KUBECONFIG }}" ]; then
              mkdir -p $HOME/.kube
              echo "${{ secrets.KUBECONFIG }}" > $HOME/.kube/config
              chmod 600 $HOME/.kube/config
              echo "✓ KUBECONFIG configured successfully"
            else
              echo "⚠️  Warning: Neither GCP_SA_KEY nor KUBECONFIG configured."
              echo "⚠️  Deployment will be skipped."
              exit 0
            fi
          fi
        env:
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}

      - name: Deploy to Kubernetes
        run: |
          IMAGE_TAG="${{ env.DOCKER_REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}"
          echo "Deploying image: $IMAGE_TAG"
          
          # Apply Kubernetes manifests (if exists)
          if [ -f "k8s/deployment.yaml" ]; then
            # Update image tag
            kubectl set image deployment/aimino-api \
              aimino-api=$IMAGE_TAG -n default || \
            kubectl apply -f k8s/deployment.yaml
            
            # Wait for deployment to complete
            kubectl rollout status deployment/aimino-api -n default --timeout=5m
          else
            echo "Warning: k8s/deployment.yaml not found. Skipping deployment."
            echo "Please create Kubernetes manifests in k8s/ directory."
          fi

      - name: Verify deployment
        run: |
          # Verify deployment success
          echo "Verifying deployment..."
          kubectl get pods -l app=aimino-api -n default
          kubectl get services -l app=aimino-api -n default
          
          # Check if pods are ready
          kubectl wait --for=condition=ready pod -l app=aimino-api -n default --timeout=2m || true
          
          echo "Deployment verification complete"

  # Generate coverage report documentation
  coverage-report:
    name: Generate Coverage Report
    runs-on: ubuntu-latest
    needs: test-summary
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-*
          merge-multiple: true

      - name: Generate coverage documentation
        run: |
          python << 'EOF'
          import xml.etree.ElementTree as ET
          import os
          
          # Parse coverage.xml
          if os.path.exists('coverage.xml'):
              tree = ET.parse('coverage.xml')
              root = tree.getroot()
              
              # Extract coverage information
              packages = root.findall('.//package')
              uncovered = []
              
              for package in packages:
                  classes = package.findall('.//class')
                  for cls in classes:
                      filename = cls.get('filename')
                      line_rate = float(cls.get('line-rate', 0))
                      if line_rate < 0.61:  # Below 61% coverage
                          lines = cls.findall('.//line')
                          uncovered_lines = [l.get('number') for l in lines if l.get('hits') == '0']
                          if uncovered_lines:
                              uncovered.append({
                                  'file': filename,
                                  'coverage': line_rate * 100,
                                  'uncovered_lines': uncovered_lines[:10]  # Show only first 10 lines
                              })
              
              # Generate documentation
              with open('COVERAGE_REPORT.md', 'w', encoding='utf-8') as f:
                  f.write("# Test Coverage Report\n\n")
                  f.write("## Overall Coverage\n\n")
                  overall_rate = float(root.get('line-rate', 0)) * 100
                  f.write(f"**Current Coverage: {overall_rate:.2f}%**\n\n")
                  f.write(f"**Target Coverage: 61%**\n\n")
                  
                  if overall_rate >= 61:
                      f.write("✅ Target coverage requirement met\n\n")
                  else:
                      f.write("❌ Target coverage requirement not met\n\n")
                  
                  f.write("## Untested or Low Coverage Modules\n\n")
                  if uncovered:
                      f.write("| File | Coverage | Uncovered Lines Example |\n")
                      f.write("|------|----------|------------------------|\n")
                      for item in uncovered:
                          lines_str = ', '.join(item['uncovered_lines'])
                          f.write(f"| {item['file']} | {item['coverage']:.1f}% | {lines_str} |\n")
                  else:
                      f.write("All modules have achieved 61% or higher coverage.\n")
          EOF

      - name: Upload coverage documentation
        uses: actions/upload-artifact@v4
        with:
          name: coverage-documentation
          path: COVERAGE_REPORT.md
